use std::sync::Arc;

use crate::store::StoreError;
use crate::Dispatcher;
use crate::Effect;

pub enum MiddlewareOp {
    /// ContinueAction is used to continue reducing the action
    ContinueAction,
    /// DoneAction is used to stop reducing the action
    DoneAction,
    /// (experimental) BreakChain is used to break the middleware chain
    BreakChain,
}

/// Middleware is a function that is called before each step of the dispatch process.
/// 'before_reduce' -> 'reduce' -> 'before_effect' -> 'effect' -> 'before_notify' -> 'notify'
///
/// if there are multiple middlewares, they are called in the order they are added
/// 'before_reduce1' -> 'before_reduce2' -> 'reduce'
///
/// if 'BreakChain' is returned, it breaks the middleware chain to 'before_xxx'
/// when reducing: 'before_reduce1': 'BreakChain' -> skip 'before_reduce2' -> 'reduce'
pub trait Middleware<State, Action> {
    /// called before reduce
    ///
    /// Arguments:
    /// - action: the action that is dispatched
    /// - state: the state after the reduce
    /// - effects: the effects that are generated by the action, effects can be consumed by the middleware
    ///
    /// Returns:
    /// - `MiddlewareOp::ContinueAction` if you want to continue the dispatch
    /// - `MiddlewareOp::DoneAction` if you want to skip the dispatch
    #[allow(unused_variables)]
    fn before_reduce(
        &self,
        action: &Action,
        state: &State,
        dispatcher: Arc<dyn Dispatcher<Action>>,
    ) -> Result<MiddlewareOp, StoreError> {
        Ok(MiddlewareOp::ContinueAction)
    }

    /// called before effect
    ///
    /// Arguments:
    /// - action: the action that is dispatched
    /// - state: the state after the reduce
    /// - effects: the effects that are generated by the action, effects can be consumed by the middleware
    ///
    /// Returns:
    /// - `MiddlewareOp::ContinueAction` if you want to continue the dispatch
    /// - `MiddlewareOp::DoneAction` if you want to skip the dispatch
    #[allow(unused_variables)]
    fn before_effect(
        &self,
        action: &Action,
        state: &State,
        effects: &mut Vec<Effect<Action>>,
        dispatcher: Arc<dyn Dispatcher<Action>>,
    ) -> Result<MiddlewareOp, StoreError> {
        Ok(MiddlewareOp::ContinueAction)
    }

    /// called before dispatch
    ///
    /// Arguments:
    /// - action: the action that is dispatched
    /// - state: the state after the reduce
    ///
    /// Returns:
    /// - `MiddlewareOp::ContinueAction` if you want to continue the dispatch
    /// - `MiddlewareOp::DoneAction` if you want to skip the dispatch
    #[allow(unused_variables)]
    fn before_dispatch(
        &self,
        action: &Action,
        state: &State,
        dispatcher: Arc<dyn Dispatcher<Action>>,
    ) -> Result<MiddlewareOp, StoreError> {
        Ok(MiddlewareOp::ContinueAction)
    }

    /// called when an error occurs
    #[allow(unused_variables)]
    fn on_error(&self, error: StoreError) {
        #[cfg(feature = "store-log")]
        eprintln!("store: Middleware error: {:?}", error);
    }
}

#[cfg(test)]
mod tests {
    use crate::{DispatchOp, Dispatcher, Reducer, StoreBuilder, StoreImpl};
    use std::sync::{Arc, Mutex};
    use std::thread;
    use std::time::Duration;

    use super::*;

    struct TestReducer;
    impl Reducer<i32, i32> for TestReducer {
        fn reduce(&self, _state: &i32, action: &i32) -> DispatchOp<i32, i32> {
            let new_state = *action;
            DispatchOp::Dispatch(new_state, None)
        }
    }

    struct LoggerMiddleware {
        logs: Mutex<Vec<String>>,
        errors: Mutex<Vec<StoreError>>,
    }

    impl LoggerMiddleware {
        fn new() -> Self {
            Self {
                logs: Mutex::new(vec![]),
                errors: Mutex::new(vec![]),
            }
        }
    }

    impl<State, Action> Middleware<State, Action> for LoggerMiddleware
    where
        State: std::fmt::Debug + Send + Sync,
        Action: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &self,
            action: &Action,
            state: &State,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            match self.logs.lock() {
                Ok(mut logs) => {
                    let log = format!("before_reduce: - Action: {:?}, state: {:?}", action, state);
                    println!("{}", log);
                    logs.push(log);
                    Ok(MiddlewareOp::ContinueAction)
                }
                Err(e) => Err(StoreError::MiddlewareError(format!(
                    "before_reduce: Failed to acquire logs lock: {}",
                    e
                ))),
            }
        }

        fn before_effect(
            &self,
            action: &Action,
            state: &State,
            _effects: &mut Vec<Effect<Action>>,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            match self.logs.lock() {
                Ok(mut logs) => {
                    let log = format!("before_effect: - Action: {:?}, state: {:?}", action, state);
                    println!("{}", log);
                    logs.push(log);
                    Ok(MiddlewareOp::ContinueAction)
                }
                Err(e) => Err(StoreError::MiddlewareError(format!(
                    "before_effect: Failed to acquire logs lock: {}",
                    e
                ))),
            }
        }

        fn on_error(&self, error: StoreError) {
            eprintln!("Middleware error: {:?}", error);
            match self.errors.lock() {
                Ok(mut errors) => {
                    errors.push(error);
                }
                Err(e) => {
                    //
                    eprintln!("Failed to acquire errors lock: {}", e);
                }
            }
        }
    }

    #[test]
    fn test_logger_middleware() {
        let reducer = Box::new(TestReducer);
        let store = StoreImpl::new_with_reducer(0, reducer).unwrap();

        // Add logger middleware
        let logger = Arc::new(LoggerMiddleware::new());
        store.add_middleware(logger.clone());

        let _ = store.dispatch(1);
        match store.stop() {
            Ok(_) => println!("store stopped"),
            Err(e) => {
                panic!("store stop failed  : {:?}", e);
            }
        }

        // reduce: 1
        // effect: 1
        assert_eq!(logger.logs.lock().unwrap().len(), 2);
        assert!(logger.logs.lock().unwrap().first().unwrap().contains("before_reduce"));
        assert!(logger.logs.lock().unwrap().last().unwrap().contains("before_effect"));
    }

    struct ChainMiddlewareContinueAction;
    impl ChainMiddlewareContinueAction {
        fn new() -> Self {
            Self {}
        }
    }
    impl<State, Action> Middleware<State, Action> for ChainMiddlewareContinueAction
    where
        State: std::fmt::Debug + Send + Sync,
        Action: std::fmt::Debug + Send + Sync,
    {
    }

    struct ChainMiddlewareDoneAction;
    impl ChainMiddlewareDoneAction {
        fn new() -> Self {
            Self {}
        }
    }

    impl<State, Action> Middleware<State, Action> for ChainMiddlewareDoneAction
    where
        State: std::fmt::Debug + Send + Sync,
        Action: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &self,
            _action: &Action,
            _state: &State,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            Ok(MiddlewareOp::DoneAction)
        }
    }

    struct ChainMiddlewareBreakChain;
    impl ChainMiddlewareBreakChain {
        fn new() -> Self {
            Self {}
        }
    }
    impl<State, Action> Middleware<State, Action> for ChainMiddlewareBreakChain
    where
        State: std::fmt::Debug + Send + Sync,
        Action: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &self,
            _action: &Action,
            _state: &State,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            Ok(MiddlewareOp::BreakChain)
        }
    }

    #[test]
    fn test_middleware_done_action() {
        // given
        let store = StoreBuilder::new(0)
            .with_reducer(Box::new(TestReducer))
            .add_middleware(Arc::new(ChainMiddlewareDoneAction::new()))
            .add_middleware(Arc::new(ChainMiddlewareContinueAction::new()))
            .build();
        assert!(store.is_ok());
        let store = store.unwrap();

        // when
        let _ = store.dispatch(42);
        match store.stop() {
            Ok(_) => println!("store stopped"),
            Err(e) => {
                panic!("store stop failed  : {:?}", e);
            }
        }

        // then
        // the state should not be changed
        assert_eq!(store.get_state(), 0);
    }

    #[test]
    fn test_middleware_break_chain() {
        let store = StoreBuilder::new(0)
            .with_reducer(Box::new(TestReducer))
            .add_middleware(Arc::new(ChainMiddlewareBreakChain::new()))
            .add_middleware(Arc::new(ChainMiddlewareContinueAction::new()))
            .build();

        assert!(store.is_ok());
        let store = store.unwrap();
        let _ = store.dispatch(1);
        match store.stop() {
            Ok(_) => println!("store stopped"),
            Err(e) => {
                panic!("store stop failed  : {:?}", e);
            }
        }

        // break chain, but continue dispatching the action
        assert_eq!(store.get_state(), 1);
    }

    #[derive(Debug, Clone)]
    enum MiddlewareAction {
        ReqThisAction(i32),
        ResponseAsThis(i32),
    }
    struct MiddlewareReducer {}
    impl MiddlewareReducer {
        fn new() -> Self {
            Self {}
        }
    }
    impl Reducer<i32, MiddlewareAction> for MiddlewareReducer {
        fn reduce(
            &self,
            _state: &i32,
            action: &MiddlewareAction,
        ) -> DispatchOp<i32, MiddlewareAction> {
            match action {
                MiddlewareAction::ReqThisAction(value) => {
                    let new_state = *value;
                    DispatchOp::Dispatch(new_state, None)
                }
                MiddlewareAction::ResponseAsThis(value) => {
                    let new_state = *value;
                    DispatchOp::Dispatch(new_state, None)
                }
            }
        }
    }

    struct MiddlewareBeforeDispatch;
    impl MiddlewareBeforeDispatch {
        fn new() -> Arc<Self> {
            Arc::new(Self {})
        }
    }
    impl<State> Middleware<State, MiddlewareAction> for MiddlewareBeforeDispatch
    where
        State: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &self,
            action: &MiddlewareAction,
            _state: &State,
            dispatcher: Arc<dyn Dispatcher<MiddlewareAction>>,
        ) -> Result<MiddlewareOp, StoreError> {
            match action {
                MiddlewareAction::ReqThisAction(v) => {
                    // do async
                    // ReqAsync -> Response
                    let v = v.clone();
                    dispatcher.dispatch_thunk(Box::new(move |dispatcher| {
                        let _ = dispatcher.dispatch(MiddlewareAction::ResponseAsThis(v + 1));
                    }));
                    // done action
                    return Ok(MiddlewareOp::DoneAction);
                }
                _ => {}
            }

            Ok(MiddlewareOp::ContinueAction)
        }
    }

    #[test]
    fn test_middleware_before_reduce() {
        // given
        let reducer = Box::new(MiddlewareReducer::new());
        let store = StoreImpl::new_with_reducer(0, reducer).unwrap();

        // when
        let effect_middleware = MiddlewareBeforeDispatch::new();
        store.add_middleware(effect_middleware.clone());

        let _ = store.dispatch(MiddlewareAction::ReqThisAction(42));
        // at this point, the state should not be changed
        assert_eq!(store.get_state(), 0);

        // give time to the effect
        thread::sleep(Duration::from_millis(1000));
        match store.stop() {
            Ok(_) => println!("store stopped"),
            Err(e) => {
                panic!("store stop failed  : {:?}", e);
            }
        }

        // the state should be changed
        assert_eq!(store.get_state(), 43);
    }

    #[derive(Debug, Clone)]
    struct EffectState {
        value: i32,
    }
    impl Default for EffectState {
        fn default() -> Self {
            Self { value: 0 }
        }
    }

    #[derive(Debug, Clone)]
    enum EffectAction {
        ActionProduceEffectFunction(i32),
        ResponseForTheEffect(i32),
    }
    struct EffectReducer {}
    impl EffectReducer {
        fn new() -> Self {
            Self {}
        }
    }
    impl Reducer<EffectState, EffectAction> for EffectReducer {
        fn reduce(
            &self,
            _state: &EffectState,
            action: &EffectAction,
        ) -> DispatchOp<EffectState, EffectAction> {
            match action {
                EffectAction::ActionProduceEffectFunction(value) => {
                    let new_state = EffectState {
                        value: value.clone(),
                    };

                    // produce an effect function
                    let value_clone = value.clone();
                    let effect = Effect::Function(
                        "key1".to_string(),
                        Box::new(move || {
                            println!("effect: {:?}", value_clone);

                            // do long running task

                            // and return result of the task
                            let new_result = Box::new(value_clone + 1);
                            Ok(new_result)
                        }),
                    );
                    DispatchOp::Dispatch(new_state, Some(effect))
                }
                EffectAction::ResponseForTheEffect(value) => {
                    let new_state = EffectState { value: *value };
                    DispatchOp::Dispatch(new_state, None)
                }
            }
        }
    }

    struct EffectMiddleware;
    impl EffectMiddleware {
        fn new() -> Self {
            Self {}
        }
    }

    impl Middleware<EffectState, EffectAction> for EffectMiddleware
    where
        EffectState: Send + Sync,
        EffectAction: Send + Sync,
    {
        fn before_effect(
            &self,
            _action: &EffectAction,
            _state: &EffectState,
            effects: &mut Vec<Effect<EffectAction>>,
            dispatcher: Arc<dyn Dispatcher<EffectAction>>,
        ) -> Result<MiddlewareOp, StoreError> {
            while effects.len() > 0 {
                let effect = effects.remove(0);
                match effect {
                    Effect::Function(tok, effect_fn) => {
                        // do async
                        dispatcher.dispatch_thunk(Box::new(move |dispatcher| {
                            // do side effect
                            let result = effect_fn();

                            // send response
                            match result {
                                Ok(new_value) => {
                                    // ensure the result type is i32
                                    assert_eq!(tok, "key1");
                                    // it is almost safe to cast.
                                    let new_result = new_value.downcast::<i32>().unwrap();
                                    // and can determine which action can be dispatched
                                    dispatcher
                                        .dispatch(EffectAction::ResponseForTheEffect(*new_result))
                                        .expect("no dispatch failed");
                                }
                                Err(e) => {
                                    eprintln!("Error: {:?}", e);
                                }
                            }
                        }));
                    }
                    _ => {
                        //assert!(false);
                        return Err(StoreError::MiddlewareError(
                            "Unexpected effect type".to_string(),
                        ));
                    }
                }
            }
            Ok(MiddlewareOp::ContinueAction)
        }
    }

    #[test]
    fn test_effect_middleware() {
        // given
        let reducer = Box::new(EffectReducer::new());
        let store = StoreImpl::new_with_reducer(EffectState::default(), reducer).unwrap();

        // when
        let effect_middleware = Arc::new(EffectMiddleware::new());
        store.add_middleware(effect_middleware.clone());

        let _ = store.dispatch(EffectAction::ActionProduceEffectFunction(42));

        // the effect produces another effect
        thread::sleep(Duration::from_millis(1000));

        match store.stop() {
            Ok(_) => println!("store stopped"),
            Err(e) => {
                panic!("store stop failed  : {:?}", e);
            }
        }

        // then
        assert_eq!(store.get_state().value, 43);
    }

    #[test]
    fn test_middleware_poisoned() {
        let reducer = Box::new(TestReducer);
        let store = StoreImpl::new_with_reducer(0, reducer).unwrap();

        // Add logger middleware
        let logger = Arc::new(LoggerMiddleware::new());

        store.add_middleware(logger.clone());

        // Poison the mutex by spawning a thread that panics while holding the lock
        let logger_clone = logger.clone();
        let handle = thread::spawn(move || {
            let _lock = logger_clone.logs.lock().unwrap();
            panic!("Intentionally poison the mutex");
        });

        // Wait for the thread to panic and poison the mutex
        let _ = handle.join().expect_err("Thread should panic");

        // Verify the mutex is poisoned
        assert!(logger.logs.lock().is_err());

        let _ = store.dispatch(1);

        match store.stop() {
            Ok(_) => println!("store stopped"),
            Err(e) => {
                panic!("store stop failed  : {:?}", e);
            }
        }

        // 2 = before_reduce, before_effect
        assert_eq!(logger.errors.lock().unwrap().len(), 2);
    }
}
