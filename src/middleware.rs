use std::sync::Arc;

use crate::Dispatcher;
use crate::Effect;
use crate::StoreError;

pub enum MiddlewareOp {
    /// ContinueAction is used to continue reducing the action
    ContinueAction,
    /// DoneAction is used to stop reducing the action
    DoneAction,
    /// BreakChain is used to break the middleware chain to 'before_reduce' or 'after_reduce'
    BreakChain,
}

/// Middleware is a function that is called before and after dispatch
/// 'before_reduce' -> 'do_reduce' -> 'after_reduce'
///
/// if there are multiple middlewares, they are called in the order they are added
/// 'before_reduce1' -> 'before_reduce2' -> 'do_reduce'
///
/// if 'BreakChain' is returned, it breaks the middleware chain to 'before_xxx'
/// when reducing: 'before_reduce1': 'BreakChain' -> skip 'before_reduce2' -> 'do_reduce'
pub trait Middleware<State, Action> {
    /// called before reduce
    ///
    /// Arguments:
    /// - action: the action that is dispatched
    /// - state: the state after the reduce
    /// - effects: the effects that are generated by the action, effects can be consumed by the middleware
    ///
    /// Returns:
    /// - `MiddlewareOp::ContinueAction` if you want to continue the dispatch
    /// - `MiddlewareOp::DoneAction` if you want to skip the dispatch
    #[allow(unused_variables)]
    fn before_reduce(
        &self,
        action: &Action,
        state: &State,
        dispatcher: Arc<dyn Dispatcher<Action>>,
    ) -> Result<MiddlewareOp, StoreError> {
        Ok(MiddlewareOp::ContinueAction)
    }

    /// called before effect
    ///
    /// Arguments:
    /// - action: the action that is dispatched
    /// - state: the state after the reduce
    /// - effects: the effects that are generated by the action, effects can be consumed by the middleware
    ///
    /// Returns:
    /// - `MiddlewareOp::ContinueAction` if you want to continue the dispatch
    /// - `MiddlewareOp::DoneAction` if you want to skip the dispatch
    #[allow(unused_variables)]
    fn before_effect(
        &self,
        action: &Action,
        state: &State,
        effects: &mut Vec<Effect<Action>>,
        dispatcher: Arc<dyn Dispatcher<Action>>,
    ) -> Result<MiddlewareOp, StoreError> {
        Ok(MiddlewareOp::ContinueAction)
    }

    /// called before dispatch
    ///
    /// Arguments:
    /// - action: the action that is dispatched
    /// - state: the state after the reduce
    ///
    /// Returns:
    /// - `MiddlewareOp::ContinueAction` if you want to continue the dispatch
    /// - `MiddlewareOp::DoneAction` if you want to skip the dispatch
    #[allow(unused_variables)]
    fn before_dispatch(
        &self,
        action: &Action,
        state: &State,
        dispatcher: Arc<dyn Dispatcher<Action>>,
    ) -> Result<MiddlewareOp, StoreError> {
        Ok(MiddlewareOp::ContinueAction)
    }
}

#[cfg(test)]
mod tests {
    use crate::{DispatchOp, Dispatcher, Reducer, StoreBuilder};
    use std::sync::{Arc, Mutex};
    use std::thread;
    use std::time::Duration;

    use super::*;

    struct TestReducer;
    impl Reducer<i32, i32> for TestReducer {
        fn reduce(&self, _state: &i32, action: &i32) -> DispatchOp<i32, i32> {
            let new_state = *action;
            DispatchOp::Dispatch(new_state, None)
        }
    }

    struct LoggerMiddleware {
        logs: Mutex<Vec<String>>,
    }

    impl LoggerMiddleware {
        fn new() -> Self {
            Self {
                logs: Mutex::new(vec![]),
            }
        }
    }

    impl<State, Action> Middleware<State, Action> for LoggerMiddleware
    where
        State: std::fmt::Debug + Send + Sync,
        Action: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &self,
            action: &Action,
            state: &State,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            let log = format!("Before reduce - Action: {:?}, state: {:?}", action, state);
            println!("{}", log);
            self.logs.lock().unwrap().push(log);
            Ok(MiddlewareOp::ContinueAction)
        }

        fn before_effect(
            &self,
            action: &Action,
            state: &State,
            _effects: &mut Vec<Effect<Action>>,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            let log = format!("Before effect - Action: {:?}, state: {:?}", action, state);
            println!("{}", log);
            self.logs.lock().unwrap().push(log);
            Ok(MiddlewareOp::ContinueAction)
        }
    }

    #[test]
    fn test_logger_middleware() {
        let reducer = Box::new(TestReducer);
        let store_result = StoreBuilder::new_with_reducer(reducer).build();

        assert!(store_result.is_ok());

        let store = store_result.unwrap();
        // Add logger middleware
        let logger = Arc::new(LoggerMiddleware::new());
        store.add_middleware(logger.clone());

        let _ = store.dispatch(1);
        store.stop();

        // reduce: 1
        // effect: 1
        assert_eq!(logger.logs.lock().unwrap().len(), 2);
        assert!(logger.logs.lock().unwrap().first().unwrap().contains("Before reduce"));
        assert!(logger.logs.lock().unwrap().last().unwrap().contains("Before effect"));
    }

    struct ChainMiddlewareContinueAction;
    impl ChainMiddlewareContinueAction {
        fn new() -> Self {
            Self {}
        }
    }
    impl<State, Action> Middleware<State, Action> for ChainMiddlewareContinueAction
    where
        State: std::fmt::Debug + Send + Sync,
        Action: std::fmt::Debug + Send + Sync,
    {}

    struct ChainMiddlewareDoneAction;
    impl ChainMiddlewareDoneAction {
        fn new() -> Self {
            Self {}
        }
    }

    impl<State, Action> Middleware<State, Action> for ChainMiddlewareDoneAction
    where
        State: std::fmt::Debug + Send + Sync,
        Action: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &self,
            _action: &Action,
            _state: &State,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            Ok(MiddlewareOp::DoneAction)
        }
    }

    struct ChainMiddlewareBreakChain;
    impl ChainMiddlewareBreakChain {
        fn new() -> Self {
            Self {}
        }
    }
    impl<State, Action> Middleware<State, Action> for ChainMiddlewareBreakChain
    where
        State: std::fmt::Debug + Send + Sync,
        Action: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &self,
            _action: &Action,
            _state: &State,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            Ok(MiddlewareOp::BreakChain)
        }
    }

    #[test]
    fn test_middleware_done_action() {
        // given
        let store = StoreBuilder::default()
            .with_reducer(Box::new(TestReducer))
            .add_middleware(Arc::new(ChainMiddlewareDoneAction::new()))
            .add_middleware(Arc::new(ChainMiddlewareContinueAction::new()))
            .build();
        assert!(store.is_ok());
        let store = store.unwrap();

        // when
        let _ = store.dispatch(42);
        store.stop();

        // then
        // the state should not be changed
        assert_eq!(store.get_state(), 0);
    }

    #[test]
    fn test_middleware_break_chain() {
        let store = StoreBuilder::default()
            .with_reducer(Box::new(TestReducer))
            .add_middleware(Arc::new(ChainMiddlewareBreakChain::new()))
            .add_middleware(Arc::new(ChainMiddlewareContinueAction::new()))
            .build();

        assert!(store.is_ok());
        let store = store.unwrap();
        let _ = store.dispatch(1);
        store.stop();

        // break chain, but continue dispatching the action
        assert_eq!(store.get_state(), 1);
    }

    #[derive(Debug, Clone)]
    enum MiddlewareAction {
        ReqThisAction(i32),
        ResponseAsThis(i32),
    }
    struct MiddlewareReducer {}
    impl MiddlewareReducer {
        fn new() -> Self {
            Self {}
        }
    }
    impl Reducer<i32, MiddlewareAction> for MiddlewareReducer {
        fn reduce(
            &self,
            _state: &i32,
            action: &MiddlewareAction,
        ) -> DispatchOp<i32, MiddlewareAction> {
            match action {
                MiddlewareAction::ReqThisAction(value) => {
                    let new_state = *value;
                    DispatchOp::Dispatch(new_state, None)
                }
                MiddlewareAction::ResponseAsThis(value) => {
                    let new_state = *value;
                    DispatchOp::Dispatch(new_state, None)
                }
            }
        }
    }

    struct MiddlewareBeforeDispatch;
    impl MiddlewareBeforeDispatch {
        fn new() -> Arc<Self> {
            Arc::new(Self {})
        }
    }
    impl<State> Middleware<State, MiddlewareAction> for MiddlewareBeforeDispatch
    where
        State: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &self,
            action: &MiddlewareAction,
            _state: &State,
            dispatcher: Arc<dyn Dispatcher<MiddlewareAction>>,
        ) -> Result<MiddlewareOp, StoreError> {
            match action {
                MiddlewareAction::ReqThisAction(v) => {
                    // do async
                    // ReqAsync -> Response
                    let v = v.clone();
                    dispatcher.dispatch_thunk(Box::new(move |dispatcher| {
                        dispatcher.dispatch(MiddlewareAction::ResponseAsThis(v + 1));
                    }));
                    // done action
                    return Ok(MiddlewareOp::DoneAction);
                }
                _ => {}
            }

            Ok(MiddlewareOp::ContinueAction)
        }
    }

    #[test]
    fn test_middleware_before_reduce() {
        // given
        let reducer = Box::new(MiddlewareReducer::new());
        let store_result = StoreBuilder::new_with_reducer(reducer).build();
        assert!(store_result.is_ok());
        let store = store_result.unwrap();

        // when
        let effect_middleware = MiddlewareBeforeDispatch::new();
        store.add_middleware(effect_middleware.clone());

        let _ = store.dispatch(MiddlewareAction::ReqThisAction(42));
        // at this point, the state should not be changed
        assert_eq!(store.get_state(), 0);

        // give time to the effect
        thread::sleep(Duration::from_millis(1000));
        store.stop();

        // the state should be changed
        assert_eq!(store.get_state(), 43);
    }

    #[derive(Clone)]
    struct EffectState {
        value: i32,
    }
    impl Default for EffectState {
        fn default() -> Self {
            Self { value: 0 }
        }
    }

    #[derive(Debug, Clone)]
    enum EffectAction {
        ActionProduceEffectFunction(i32),
        ResponseForTheEffect(i32),
    }
    struct EffectReducer {}
    impl EffectReducer {
        fn new() -> Self {
            Self {}
        }
    }
    impl Reducer<EffectState, EffectAction> for EffectReducer {
        fn reduce(
            &self,
            _state: &EffectState,
            action: &EffectAction,
        ) -> DispatchOp<EffectState, EffectAction> {
            match action {
                EffectAction::ActionProduceEffectFunction(value) => {
                    let new_state = EffectState {
                        value: value.clone(),
                    };

                    // produce an effect function
                    let value_clone = value.clone();
                    let effect = Effect::Function(
                        "key1".to_string(),
                        Box::new(move || {
                            println!("effect: {:?}", value_clone);

                            // do long running task

                            // and return result of the task
                            let new_result = Box::new(value_clone + 1);
                            Ok(new_result)
                        }),
                    );
                    DispatchOp::Dispatch(new_state, Some(effect))
                }
                EffectAction::ResponseForTheEffect(value) => {
                    let new_state = EffectState { value: *value };
                    DispatchOp::Dispatch(new_state, None)
                }
            }
        }
    }

    struct EffectMiddleware;
    impl EffectMiddleware {
        fn new() -> Self {
            Self {}
        }
    }

    impl Middleware<EffectState, EffectAction> for EffectMiddleware
    where
        EffectState: Send + Sync,
        EffectAction: Send + Sync,
    {
        fn before_effect(
            &self,
            _action: &EffectAction,
            _state: &EffectState,
            effects: &mut Vec<Effect<EffectAction>>,
            dispatcher: Arc<dyn Dispatcher<EffectAction>>,
        ) -> Result<MiddlewareOp, StoreError> {
            while effects.len() > 0 {
                let effect = effects.remove(0);
                match effect {
                    Effect::Function(tok, effect_fn) => {
                        // do async
                        dispatcher.dispatch_thunk(Box::new(move |dispatcher| {
                            // do side effect
                            let result = effect_fn();

                            // send response
                            match result {
                                Ok(new_value) => {
                                    // ensure the result type is i32
                                    assert_eq!(tok, "key1");
                                    // it is almost safe to cast.
                                    let new_result = new_value.downcast::<i32>().unwrap();
                                    // and can determine which action can be dispatched
                                    dispatcher
                                        .dispatch(EffectAction::ResponseForTheEffect(*new_result));
                                }
                                Err(e) => {
                                    println!("Error: {:?}", e);
                                }
                            }
                        }));
                    }
                    _ => {
                        assert!(false);
                    }
                }
            }
            Ok(MiddlewareOp::ContinueAction)
        }
    }

    #[test]
    fn test_effect_middleware() {
        // given
        let reducer = Box::new(EffectReducer::new());
        let store_result = StoreBuilder::new_with_reducer(reducer).build();
        assert!(store_result.is_ok());

        // when
        let store: Arc<crate::Store<EffectState, EffectAction>> = store_result.unwrap();
        let effect_middleware = Arc::new(EffectMiddleware::new());
        store.add_middleware(effect_middleware.clone());

        let _ = store.dispatch(EffectAction::ActionProduceEffectFunction(42));

        // the effect produces another effect
        thread::sleep(Duration::from_millis(1000));

        store.stop();

        // then
        assert_eq!(store.get_state().value, 43);
    }
}
