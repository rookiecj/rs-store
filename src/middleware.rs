use std::sync::Arc;

use crate::Dispatcher;
use crate::Effect;
use crate::StoreError;

pub enum MiddlewareOp {
    /// ContinueAction is used to continue reducing the action
    ContinueAction,
    /// DoneAction is used to stop reducing the action
    DoneAction,
    /// BreakChain is used to break the middleware chain to 'before_reduce' or 'after_reduce'
    BreakChain,
}

/// Middleware is a function that is called before and after dispatch
/// 'before_reduce' -> 'do_reduce' -> 'after_reduce'
///
/// if there are multiple middlewares, they are called in the order they are added
/// and the order of 'after_reduce' is the reverse order of 'before_reduce'
/// 'before_reduce1' -> 'before_reduce2' -> 'do_reduce' -> 'after_reduce2' -> 'after_reduce1'
///
/// if 'BreakChain' is returned, it breaks the middleware chain to 'before_reduce' or 'after_reduce'
/// 'before_reduce1': 'BreakChain' -> skip 'before_reduce2' -> 'do_reduce' -> skip 'after_reduce2' -> 'after_reduce1'
pub trait Middleware<State, Action>: Send + Sync
where
    State: Send + Sync,
    Action: Send + Sync,
{
    /// called before reduce
    ///
    /// Returns:
    /// - MiddlewareOp::Continue if you want to continue the dispatch
    /// - MiddlewareOp::Skip if you want to skip the dispatch
    fn before_reduce(
        &mut self,
        action: &Action,
        state: &State,
        dispatcher: Arc<dyn Dispatcher<Action>>,
    ) -> Result<MiddlewareOp, StoreError>;

    /// called after reduce
    ///
    /// Arguments:
    /// - action: the action that is dispatched
    /// - old_state: the state before the dispatch
    /// - new_state: the state after the dispatch
    /// - effects: the effects that are generated by the action, effects can be comsumed by the middleware
    ///
    ///
    /// Returns:
    /// - MiddlewareOp::Continue if you want to continue the dispatch
    /// - MiddlewareOp::Skip if you want to skip the dispatch
    fn after_reduce(
        &mut self,
        action: &Action,
        old_state: &State,
        new_state: &State,
        effects: &mut Vec<Effect<Action>>,
        dispatcher: Arc<dyn Dispatcher<Action>>,
    ) -> Result<MiddlewareOp, StoreError>;
}

#[cfg(test)]
mod tests {
    use crate::{DispatchOp, Dispatcher, Reducer, StoreBuilder};
    use std::sync::{Arc, Mutex};
    use std::thread;
    use std::time::Duration;

    use super::*;

    struct TestReducer;
    impl Reducer<i32, i32> for TestReducer {
        fn reduce(&self, _state: &i32, action: &i32) -> DispatchOp<i32, i32> {
            let new_state = *action;
            DispatchOp::Dispatch(new_state, None)
        }
    }

    struct LoggerMiddleware {
        logs: Vec<String>,
    }

    impl LoggerMiddleware {
        fn new() -> Self {
            Self { logs: vec![] }
        }
    }

    impl<State, Action> Middleware<State, Action> for LoggerMiddleware
    where
        State: std::fmt::Debug + Send + Sync,
        Action: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &mut self,
            action: &Action,
            state: &State,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            let log = format!("Before dispatch - Action: {:?}, state: {:?}", action, state);
            println!("{}", log);
            self.logs.push(log);
            Ok(MiddlewareOp::ContinueAction)
        }

        fn after_reduce(
            &mut self,
            action: &Action,
            old_state: &State,
            new_state: &State,
            _effects: &mut Vec<Effect<Action>>,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            let log = format!(
                "After dispatch - Action: {:?}, state: {:?} -> {:?}",
                action, old_state, new_state
            );
            println!("{}", log);
            self.logs.push(log);
            Ok(MiddlewareOp::ContinueAction)
        }
    }

    #[test]
    fn test_logger_middleware() {
        let reducer = Box::new(TestReducer);
        let store_result = StoreBuilder::new(reducer).build();

        assert!(store_result.is_ok());

        let store = store_result.unwrap();
        // Add logger middleware
        let logger = Arc::new(Mutex::new(LoggerMiddleware::new()));
        store.add_middleware(logger.clone());

        let _ = store.dispatch(1);
        store.stop();

        assert_eq!(logger.lock().unwrap().logs.len(), 2);
        assert!(logger.lock().unwrap().logs.first().unwrap().contains("Before dispatch"));
        assert!(logger.lock().unwrap().logs.last().unwrap().contains("After dispatch"));
    }

    struct ChainMiddlewareContinueAction;
    impl ChainMiddlewareContinueAction {
        fn new() -> Self {
            Self {}
        }
    }
    impl<State, Action> Middleware<State, Action> for ChainMiddlewareContinueAction
    where
        State: std::fmt::Debug + Send + Sync,
        Action: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &mut self,
            _action: &Action,
            _state: &State,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            Ok(MiddlewareOp::ContinueAction)
        }

        fn after_reduce(
            &mut self,
            _action: &Action,
            _old_state: &State,
            _new_state: &State,
            _effects: &mut Vec<Effect<Action>>,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            Ok(MiddlewareOp::ContinueAction)
        }
    }

    struct ChainMiddlewareDoneAction;
    impl ChainMiddlewareDoneAction {
        fn new() -> Self {
            Self {}
        }
    }

    impl<State, Action> Middleware<State, Action> for ChainMiddlewareDoneAction
    where
        State: std::fmt::Debug + Send + Sync,
        Action: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &mut self,
            _action: &Action,
            _state: &State,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            Ok(MiddlewareOp::DoneAction)
        }

        fn after_reduce(
            &mut self,
            _action: &Action,
            _old_state: &State,
            _new_state: &State,
            _effects: &mut Vec<Effect<Action>>,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            Ok(MiddlewareOp::ContinueAction)
        }
    }

    struct ChainMiddlewareBreakChain;
    impl ChainMiddlewareBreakChain {
        fn new() -> Self {
            Self {}
        }
    }
    impl<State, Action> Middleware<State, Action> for ChainMiddlewareBreakChain
    where
        State: std::fmt::Debug + Send + Sync,
        Action: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &mut self,
            _action: &Action,
            _state: &State,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            Ok(MiddlewareOp::BreakChain)
        }

        fn after_reduce(
            &mut self,
            _action: &Action,
            _old_state: &State,
            _new_state: &State,
            _effects: &mut Vec<Effect<Action>>,
            _dispatcher: Arc<dyn Dispatcher<Action>>,
        ) -> Result<MiddlewareOp, StoreError> {
            Ok(MiddlewareOp::ContinueAction)
        }
    }

    #[test]
    fn test_middleware_done_action() {
        // given
        let store = StoreBuilder::default()
            .with_reducer(Box::new(TestReducer))
            .add_middleware(Arc::new(Mutex::new(ChainMiddlewareDoneAction::new())))
            .add_middleware(Arc::new(Mutex::new(ChainMiddlewareContinueAction::new())))
            .build();
        assert!(store.is_ok());
        let store = store.unwrap();

        // when
        let _ = store.dispatch(42);
        store.stop();

        // then
        // the state should not be changed
        assert_eq!(store.get_state(), 0);
    }

    #[test]
    fn test_middleware_break_chain() {
        let store = StoreBuilder::default()
            .with_reducer(Box::new(TestReducer))
            .add_middleware(Arc::new(Mutex::new(ChainMiddlewareBreakChain::new())))
            .add_middleware(Arc::new(Mutex::new(ChainMiddlewareContinueAction::new())))
            .build();

        assert!(store.is_ok());
        let store = store.unwrap();
        let _ = store.dispatch(1);
        store.stop();

        // break chain, but continue dispatching the action
        assert_eq!(store.get_state(), 1);
    }

    #[derive(Debug)]
    enum MiddlewareAction {
        ReqThisAction(i32),
        ResponseAsThis(i32),
    }
    struct MiddlewareReducer {}
    impl MiddlewareReducer {
        fn new() -> Self {
            Self {}
        }
    }
    impl Reducer<i32, MiddlewareAction> for MiddlewareReducer {
        fn reduce(
            &self,
            _state: &i32,
            action: &MiddlewareAction,
        ) -> DispatchOp<i32, MiddlewareAction> {
            match action {
                MiddlewareAction::ReqThisAction(value) => {
                    let new_state = *value;
                    DispatchOp::Dispatch(new_state, None)
                }
                MiddlewareAction::ResponseAsThis(value) => {
                    let new_state = *value;
                    DispatchOp::Dispatch(new_state, None)
                }
            }
        }
    }

    struct MiddlewareBeforeDispatch;
    impl MiddlewareBeforeDispatch {
        fn new() -> Arc<Mutex<Self>> {
            Arc::new(Mutex::new(Self {}))
        }
    }
    impl<State> Middleware<State, MiddlewareAction> for MiddlewareBeforeDispatch
    where
        State: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &mut self,
            action: &MiddlewareAction,
            _state: &State,
            dispatcher: Arc<dyn Dispatcher<MiddlewareAction>>,
        ) -> Result<MiddlewareOp, StoreError> {
            match action {
                MiddlewareAction::ReqThisAction(v) => {
                    // do async
                    // ReqAsync -> Response
                    let v = v.clone();
                    dispatcher.dispatch_thunk(Box::new(move |dispatcher| {
                        dispatcher.dispatch(MiddlewareAction::ResponseAsThis(v + 1));
                    }));
                    // done action
                    return Ok(MiddlewareOp::DoneAction);
                }
                _ => {}
            }

            Ok(MiddlewareOp::ContinueAction)
        }

        fn after_reduce(
            &mut self,
            _action: &MiddlewareAction,
            _old_state: &State,
            _new_state: &State,
            _effects: &mut Vec<Effect<MiddlewareAction>>,
            _dispatcher: Arc<dyn Dispatcher<MiddlewareAction>>,
        ) -> Result<MiddlewareOp, StoreError> {
            Ok(MiddlewareOp::ContinueAction)
        }
    }

    #[test]
    fn test_middleware_before_reduce() {
        // given
        let reducer = Box::new(MiddlewareReducer::new());
        let store_result = StoreBuilder::new(reducer).build();
        assert!(store_result.is_ok());
        let store = store_result.unwrap();

        // when
        let effect_middleware = MiddlewareBeforeDispatch::new();
        store.add_middleware(effect_middleware.clone());

        let _ = store.dispatch(MiddlewareAction::ReqThisAction(42));
        // at this point, the state should not be changed
        assert_eq!(store.get_state(), 0);

        // give time to the effect
        thread::sleep(Duration::from_secs(1));
        store.stop();

        // the state should be changed
        assert_eq!(store.get_state(), 43);
    }

    #[derive(Debug)]
    enum EffectAction {
        ActionProduceEffect(i32),
        ResponseForTheEffect(i32),
    }
    struct EffectReducer {}
    impl EffectReducer {
        fn new() -> Self {
            Self {}
        }
    }
    impl Reducer<i32, EffectAction> for EffectReducer {
        fn reduce(&self, _state: &i32, action: &EffectAction) -> DispatchOp<i32, EffectAction> {
            match action {
                EffectAction::ActionProduceEffect(value) => {
                    let new_state = *value;
                    // produce an effect w/o an action.
                    let effect = Effect::Function(Box::new(move || {
                        println!("effect: {:?}", new_state);
                    }));
                    DispatchOp::Dispatch(new_state, Some(effect))
                }
                EffectAction::ResponseForTheEffect(value) => {
                    let new_state = *value;
                    DispatchOp::Dispatch(new_state, None)
                }
            }
        }
    }

    struct EffectMiddleware;
    impl EffectMiddleware {
        fn new() -> Arc<Mutex<Self>> {
            Arc::new(Mutex::new(Self {}))
        }
    }
    impl<State> Middleware<State, EffectAction> for EffectMiddleware
    where
        State: std::fmt::Debug + Send + Sync,
    {
        fn before_reduce(
            &mut self,
            _action: &EffectAction,
            _state: &State,
            _dispatcher: Arc<dyn Dispatcher<EffectAction>>,
        ) -> Result<MiddlewareOp, StoreError> {
            Ok(MiddlewareOp::ContinueAction)
        }

        fn after_reduce(
            &mut self,
            action: &EffectAction,
            _old_state: &State,
            _new_state: &State,
            effects: &mut Vec<Effect<EffectAction>>,
            dispatcher: Arc<dyn Dispatcher<EffectAction>>,
        ) -> Result<MiddlewareOp, StoreError> {
            match action {
                EffectAction::ActionProduceEffect(v) => {
                    while effects.len() > 0 {
                        let effect = effects.remove(0);
                        match effect {
                            Effect::Function(effect_fn) => {
                                // do async
                                let v: i32 = v.clone();
                                dispatcher.dispatch_thunk(Box::new(move |dispatcher| {
                                    // do side effect
                                    effect_fn();
                                    // send response
                                    dispatcher.dispatch(EffectAction::ResponseForTheEffect(v + 1));
                                }));
                            }
                            _ => {
                                assert!(false);
                            }
                        }
                    }
                }
                _ => {}
            }
            Ok(MiddlewareOp::ContinueAction)
        }
    }

    #[test]
    fn test_effect_middleware() {
        // given
        let reducer = Box::new(EffectReducer::new());
        let store_result = StoreBuilder::new(reducer).build();
        assert!(store_result.is_ok());

        // when
        let store: Arc<crate::Store<i32, EffectAction>> = store_result.unwrap();
        let effect_middleware = EffectMiddleware::new();
        store.add_middleware(effect_middleware.clone());

        let _ = store.dispatch(EffectAction::ActionProduceEffect(42));
        // give time for the effect
        thread::sleep(Duration::from_secs(1));
        store.stop();

        // then
        assert_eq!(store.get_state(), 43);
    }
}
